using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Net;
using System.Net.Sockets;
using System.Threading;
using Newtonsoft.Json;
using System.Drawing.Imaging;

namespace FractalServer
{
	public class Logic
	{
		var localEndPoint = new IPEndPoint(IPAddress.Any, 9001);
		public var RenderFarm = new List<Worker>();
		public var JobList = new List<Job>();
		public var ThreadList = new List<Thread>();
		var socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
		public Thread ClientThread;
		public var xmin = -2.1;
		public var ymin = -1.3;
		public var xmax = 1;
		public var ymax = 1.3;
		public var running = false;
		public Bitmap tempBitmap;

		public void Connect()
		{
			socket.Bind(localEndPoint);
			socket.Listen(100);
			while (true)
			{
				Socket clientSocket = socket.Accept();
				Console.WriteLine("A new client connected");
				byte[] bytes = new byte[1024];
				clientSocket.Receive(bytes);

				Worker temp = new Worker()
				{
					IP = localEndPoint.Address, //TODO Not the right address, merly a placeholder
					Socket = clientSocket,
					Threads = Convert.ToUInt16(Encoding.ASCII.GetString(bytes))
				};
				RenderFarm.Add(temp);
				ClientThread = new Thread(() =>
				{
					Resive(temp);
				});
				ClientThread.Start();
				ThreadList.Add(ClientThread);
				ClientDatagridview.Rows.Add(temp.IP.ToString(), temp.Threads.ToString());
				ClientDatagridview.Update();
			}
		}

		public void Send(Worker worker) //Call this for each worker that needs a job
		{
			Job job = GetJob();
			if (job != null)
			{
				string jobString = JsonConvert.SerializeObject(job);    //Converts the job Object to a json string
				Byte[] jobByte = Encoding.ASCII.GetBytes(jobString);    //Converts that string to bytes
				worker.Socket.Send(jobByte);                            //Sends those bytes to worker
			}
			else
			{
				running = false;
			}   //sets running to false if there is no more jobs
		}

		public Job GetJob()
		{
			if (JobList.Count > 0)  //Yes this should/couldl be done with a queue..
			{
				Job job = JobList.FirstOrDefault();
				JobList.Remove(job);
				return job;
			}
			else
			{
				return null;
			}
		}

		public void SetUpJobs()
		{
			running = true;
			Job job = new Job();
			double halfHeight = ymax - (ymax - ymin) / 2;
			double jobXLenth = (xmax - xmin) / RenderFarm.Count;
			for (ushort i = 0; i < RenderFarm.Count * 2; i++)
			{
				double tmp;
				if (i > RenderFarm.Count) { tmp = halfHeight; }
				else { tmp = ymin; }
				job.ID = i;
				job.ymin = tmp;
				if (i < RenderFarm.Count) { tmp = halfHeight; }
				else { tmp = ymax; }
				job.ymax = tmp;
				job.xmax = xmin + i * jobXLenth; //FIXME Fixed?
				job.xmin = xmin + (i - 1) * jobXLenth % RenderFarm.Count;
				int width = factalPictureBox.Width;
				int height = factalPictureBox.Height;
				job.height = factalPictureBox.Height / 2;
				job.width = factalPictureBox.Width / RenderFarm.Count;

				JobList.Add(job);
			}
		}
		public void RenderThis(Piece piece, int lastPlacement, byte[] bytes)
		{
			int y;
			int x;
			int startX = (piece.ID % RenderFarm.Count) * piece.xLenth;
			int startY = (piece.ID / RenderFarm.Count) * (factalPictureBox.Height / 2);
			for (int i = 0; i < 8175;)
			{
				if (i > 800)
				{
					int placement = lastPlacement + (i / 2);
					y = startY + placement / piece.xLenth;
					x = startX + placement - (y - startY) * piece.xLenth;
					ushort color = BitConverter.ToUInt16(bytes, i + 15);
					tempBitmap.SetPixel(x, y, Color.FromArgb(color, 0, 0));
					i += 2;
				}
				else
				{
					int placement = lastPlacement + (i / 2);
					y = startY + placement / piece.xLenth;
					x = startX + placement - (y - startY) * piece.xLenth;
					ushort color = BitConverter.ToUInt16(bytes, i + 15);
					tempBitmap.SetPixel(x, y, Color.FromArgb(color, 0, 0));
					i += 2;
				}
			}
			factalPictureBox.Image = tempBitmap;
			factalPictureBox.Update();
			//foreach (var i in piece.pixels)
			//{
			//	if (piece.ID < RenderFarm.Count)
			//	{
			//		y = Convert.ToInt32(i.Placement) / piece.xLenth;
			//		x = (piece.xLenth * piece.ID) + Convert.ToInt32(i.Placement) % piece.xLenth;
			//	}
			//	else
			//	{
			//		y = factalPictureBox.Height / 2 + Convert.ToInt32(i.Placement) / piece.xLenth;
			//		x = (piece.xLenth * Convert.ToInt32(piece.ID / 2)) + Convert.ToInt32(i.Placement) % piece.xLenth;
			//	}
			//	//int x = (piece.xLenth * piece.ID) + Convert.ToInt32(i.Placement) % piece.xLenth;
			//	try
			//	{
			//		tempBitmap.SetPixel(x, y, Color.FromArgb(i.color, 0, 0));
			//	}
			//	catch (Exception ex)
			//	{
			//		MessageBox.Show(ex.Message + "");
			//	}
			//	//factalPictureBox.Image = tempBitmap;
			//	//factalPictureBox.Update();
			//	//tempBitmap.Save("myfilebla.png", ImageFormat.Png);
			//}
		}

		public void FormPiece(byte[] bytes)
		{
			//Piece piece = new Piece();

			//byte[] byteID = CopyPartOfArray(2, 0, bytes);
			//byte[] byteXLenth = CopyPartOfArray(4, 2, bytes);
			//byte[] byteRunning = CopyPartOfArray(1, 6, bytes);
			//byte[] bytePlacement = CopyPartOfArray(4, 10, bytes);
			//piece.ID = BitConverter.ToUInt16(bytes, 0);
			//piece.xLenth = BitConverter.ToInt32(bytes, 2);
			//piece.done = BitConverter.ToBoolean(bytes, 6);
			//int placement = BitConverter.ToInt32(bytes, 7);
			//RenderThis(piece, placement, bytes);
		}

		public byte[] CopyPartOfArray(int arraySize, int startCopyAt, byte[] fromArray)
		{
			byte[] byteTemp = new byte[arraySize];
			for (int a = 0; a < arraySize; a++)
			{
				byteTemp[a] = fromArray[startCopyAt + a];
			}
			return byteTemp;
		}

		public void Resive(Worker worker)
		{
			try
			{
				while (true)
				{
					byte[] bytes = new byte[8192];
					//string pieceString = "";
					//while (worker.Socket.Receive(bytes) > 0)  //This might not be needed anymore, the client now sends every time a buffer is full
					//{
					//	pieceString += Encoding.ASCII.GetString(bytes);
					//}
					worker.Socket.Receive(bytes);


					//string pieceString = Encoding.ASCII.GetString(bytes);
					//Piece piece = JsonConvert.DeserializeObject<Piece>(pieceString);
					//ClientThread = new Thread(() =>
					//{
					//	FormPiece(bytes);
					//});
					//ClientThread.Start();
					Piece piece = new Piece();
					piece.ID = BitConverter.ToUInt16(bytes, 0);
					piece.xLenth = BitConverter.ToInt32(bytes, 2);
					piece.done = BitConverter.ToBoolean(bytes, 6);
					int placement = BitConverter.ToInt32(bytes, 7);
					RenderThis(piece, placement, bytes);
					//int y;
					//int x;
					//foreach (var i in piece.pixels)
					//{
					//	if (piece.ID < RenderFarm.Count)
					//	{
					//		y = Convert.ToInt32(i.Placement) / piece.xLenth;
					//		x = (piece.xLenth * piece.ID) + Convert.ToInt32(i.Placement) % piece.xLenth;
					//	}
					//	else
					//	{
					//		y = factalPictureBox.Height / 2 + Convert.ToInt32(i.Placement) / piece.xLenth;
					//		x = (piece.xLenth * Convert.ToInt32(piece.ID / 2)) + Convert.ToInt32(i.Placement) % piece.xLenth;
					//	}
					//	//int x = (piece.xLenth * piece.ID) + Convert.ToInt32(i.Placement) % piece.xLenth;
					//	try
					//	{
					//		tempBitmap.SetPixel(x, y, Color.FromArgb(i.color, 0, 0));
					//	}
					//	catch (Exception ex)
					//	{
					//		MessageBox.Show(ex.Message + "");
					//	}

					//}

					//factalPictureBox.Image = tempBitmap;
					//factalPictureBox.Update();
					//tempBitmap.Save("myfilebla.png", ImageFormat.Png);

					//if (piece.done == true)
					//{   //If there still are jobs to be done, send the worker a new one
					//	Send(worker);
					//}
					bytes = null;
				}
			}
			catch (Exception)
			{
				//TODO: Make a popup that askes to remove the tread or retry
				Thread.CurrentThread.Abort();
			}
		}

		private void RenderBtn_Click(object sender, EventArgs e)
		{
			//SetUpJobs();
			Job bla = new Job()
			{
				ID = 1,
				ymin = ymin,
				ymax = ymax,
				xmax = xmax,
				xmin = xmin,
				height = factalPictureBox.Height,
				width = factalPictureBox.Width
			};
			factalPictureBox.Image = Render(bla);
			factalPictureBox.Update();
		}
		public Bitmap Render(Job job)
		{
			// Holds all of the possible colors
			//Color[] cs = new Color[256]; //Not used as of this time

			// Creates the Bitmap we draw to
			Bitmap b = new Bitmap(job.width, job.height);
			// From here on out is just converted from the c++ version.
			double x, y, x1, y1, xx, intigralX, intigralY = 0.0;

			int looper, s, z = 0;
			intigralX = (job.xmax - job.xmin) / b.Width; // Make it fill the whole window
			intigralY = (job.ymax - job.ymin) / b.Height;
			x = job.xmin;

			for (s = 1; s < b.Width; s++)
			{
				y = job.ymin;
				for (z = 1; z < b.Height; z++)
				{
					x1 = 0;
					y1 = 0;
					looper = 0;
					while (looper < 250 && Math.Sqrt((x1 * x1) + (y1 * y1)) < 2)
					{
						looper++;
						xx = (x1 * x1) - (y1 * y1) + x;
						y1 = 2 * x1 * y1 + y;
						x1 = xx;
					}

					// Get the percent of where the looper stopped
					double perc = looper / (250.0);
					// Get that part of a 255 scale
					int val = ((int)(perc * 255));
					// Use that number to set the color
					Color color = Color.FromArgb(val, 0, 0);
					b.SetPixel(s, z, color);
					y += intigralY;
				}
				x += intigralX;
			}
			return b;
		}

		private void factalPictureBox_MouseDoubleClick(object sender, MouseEventArgs e)
		{
			double temp = (xmax - xmin) / 4;
			double tempX = xmin + (xmax - xmin) * (Convert.ToDouble(e.X) / factalPictureBox.Width);
			double tempY = ymin + (ymax - ymin) * (Convert.ToDouble(e.Y) / factalPictureBox.Height);
			xmin = tempX - temp;
			xmax = tempX + temp;
			ymin = tempY - temp;
			ymax = tempY + temp;
			Job job = new Job();

			if (true)
			{
				job.ymin = ymin;
				job.ymax = ymax;
				job.xmax = xmax;
				job.xmin = xmin;
				job.height = factalPictureBox.Height;
				job.width = factalPictureBox.Width;
			}
			factalPictureBox.Image = Render(job);
			factalPictureBox.Update();
		}

		private void button1_Click(object sender, EventArgs e)
		{
			factalPictureBox.Image = tempBitmap;
			factalPictureBox.Update();
			//xmin = -2.1;
			//ymin = -1.3;
			//xmax = 1.0;
			//ymax = 1.3;
		}

		private void SaveBtn_Click(object sender, EventArgs e)
		{
			SetUpJobs();
			foreach (var i in RenderFarm)
			{
				Send(i);
			}

			//int kSize = 100;  //This is the number of vertical and horizontal pixels
			//Job bla = new Job()
			//{
			//	ID = 2,
			//	ymin = ymin,
			//	ymax = ymax,
			//	xmax = xmax,
			//	xmin = xmin,
			//	height = kSize,
			//	width = kSize
			//};
			//Bitmap bit = Render(bla);	//Renders the picture as a bitmap
			//bit.Save("myfile2.bmp", ImageFormat.Bmp);	//saves the bit bitmap as a .Bmp

		}

		private void Form1_Load(object sender, EventArgs e)
		{
			tempBitmap = new Bitmap(
				Height = factalPictureBox.Height,
				Width = factalPictureBox.Width);
		}

		private void Form1_FormClosing(object sender, FormClosingEventArgs e)
		{
			foreach (var iThread in ThreadList)
			{
				iThread.Abort();
			}
		}
	}
}
